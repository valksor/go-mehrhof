package github

import (
	"context"
	"fmt"
	"strings"

	"github.com/valksor/go-mehrhof/internal/provider"
	"github.com/valksor/go-mehrhof/internal/storage"
)

// CreatePullRequest creates a new pull request on GitHub
func (p *Provider) CreatePullRequest(ctx context.Context, opts provider.PullRequestOptions) (*provider.PullRequest, error) {
	// Use provider's default owner/repo if not specified in metadata
	owner := p.owner
	repo := p.repo

	if owner == "" || repo == "" {
		return nil, ErrRepoNotConfigured
	}

	p.client.SetOwnerRepo(owner, repo)

	// Determine target branch
	targetBranch := opts.TargetBranch
	if targetBranch == "" {
		// Try to get from config
		if p.config != nil && p.config.TargetBranch != "" {
			targetBranch = p.config.TargetBranch
		} else {
			// Detect default branch from repo
			defaultBranch, err := p.client.GetDefaultBranch(ctx)
			if err != nil {
				return nil, fmt.Errorf("detect default branch: %w", err)
			}
			targetBranch = defaultBranch
		}
	}

	// Determine if draft
	draft := opts.Draft
	if p.config != nil && p.config.DraftPR {
		draft = true
	}

	// Create the PR
	ghPR, err := p.client.CreatePullRequest(ctx, opts.Title, opts.Body, opts.SourceBranch, targetBranch, draft)
	if err != nil {
		return nil, err
	}

	return &provider.PullRequest{
		ID:     fmt.Sprintf("%d", ghPR.GetID()),
		Number: ghPR.GetNumber(),
		URL:    ghPR.GetHTMLURL(),
		Title:  ghPR.GetTitle(),
		State:  ghPR.GetState(),
	}, nil
}

// GeneratePRTitle generates a PR title from task metadata
func GeneratePRTitle(taskWork *storage.TaskWork) string {
	if taskWork == nil {
		return "Implementation"
	}

	var title string
	if taskWork.Metadata.ExternalKey != "" {
		title = fmt.Sprintf("[#%s] ", taskWork.Metadata.ExternalKey)
	}

	if taskWork.Metadata.Title != "" {
		title += taskWork.Metadata.Title
	} else {
		title += "Implementation"
	}

	return title
}

// GeneratePRBody generates a PR body with implementation summary
func GeneratePRBody(taskWork *storage.TaskWork, specs []*storage.Specification, diffStat string) string {
	var sb strings.Builder

	// Summary section
	sb.WriteString("## Summary\n\n")

	if taskWork != nil && taskWork.Metadata.Title != "" {
		sb.WriteString(fmt.Sprintf("Implementation for: %s\n\n", taskWork.Metadata.Title))
	}

	// Link to issue if this is a GitHub issue task
	if taskWork != nil && taskWork.Source.Type == "github" {
		sb.WriteString(fmt.Sprintf("Closes #%s\n\n", taskWork.Metadata.ExternalKey))
	}

	// Specifications section
	if len(specs) > 0 {
		sb.WriteString("## Implementation Details\n\n")
		for _, spec := range specs {
			if spec.Title != "" {
				sb.WriteString(fmt.Sprintf("### %s\n\n", spec.Title))
			}
			// Include first 500 chars of spec content as summary
			content := spec.Content
			if len(content) > 500 {
				content = content[:500] + "..."
			}
			sb.WriteString(content)
			sb.WriteString("\n\n")
		}
	}

	// Changes section
	if diffStat != "" {
		sb.WriteString("## Changes\n\n")
		sb.WriteString("```\n")
		sb.WriteString(diffStat)
		sb.WriteString("\n```\n\n")
	}

	// Test plan section (placeholder)
	sb.WriteString("## Test Plan\n\n")
	sb.WriteString("- [ ] Manual testing\n")
	sb.WriteString("- [ ] Unit tests pass\n")
	sb.WriteString("- [ ] Code review\n\n")

	// Footer
	sb.WriteString("---\n")
	sb.WriteString("*Generated by [Mehrhof](https://github.com/valksor/go-mehrhof)*\n")

	return sb.String()
}

// GetDefaultBranch returns the repository's default branch
func (p *Provider) GetDefaultBranch(ctx context.Context) (string, error) {
	if p.config != nil && p.config.TargetBranch != "" {
		return p.config.TargetBranch, nil
	}
	return p.client.GetDefaultBranch(ctx)
}

// PROptions holds options for PR creation (extends provider.PullRequestOptions)
type PROptions struct {
	provider.PullRequestOptions

	// Additional GitHub-specific options
	MaintainerCanModify bool
	IssueNumber         int // Issue to close when PR is merged
}

// CreatePRFromTask creates a PR from task context
func (p *Provider) CreatePRFromTask(ctx context.Context, taskWork *storage.TaskWork, specs []*storage.Specification, sourceBranch, diffStat string) (*provider.PullRequest, error) {
	title := GeneratePRTitle(taskWork)
	body := GeneratePRBody(taskWork, specs, diffStat)

	opts := provider.PullRequestOptions{
		Title:        title,
		Body:         body,
		SourceBranch: sourceBranch,
		TargetBranch: "", // Will use default
		Draft:        p.config != nil && p.config.DraftPR,
	}

	// Note: Labels could be added via GitHub API after PR creation if needed

	return p.CreatePullRequest(ctx, opts)
}
