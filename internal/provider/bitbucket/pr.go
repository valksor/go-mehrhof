package bitbucket

import (
	"context"
	"fmt"
	"strings"

	"github.com/valksor/go-mehrhof/internal/provider"
	"github.com/valksor/go-mehrhof/internal/storage"
)

// CreatePullRequest creates a new pull request on Bitbucket
// This implements the provider.PRCreator interface
func (p *Provider) CreatePullRequest(ctx context.Context, opts provider.PullRequestOptions) (*provider.PullRequest, error) {
	// Ensure workspace/repo is configured
	workspace := p.config.Workspace
	repoSlug := p.config.RepoSlug

	if workspace == "" || repoSlug == "" {
		return nil, ErrRepoNotConfigured
	}

	p.client.SetWorkspaceRepo(workspace, repoSlug)

	// Determine target branch
	targetBranch := opts.TargetBranch
	if targetBranch == "" {
		if p.config.TargetBranch != "" {
			targetBranch = p.config.TargetBranch
		} else {
			// Detect default branch from repo
			defaultBranch, err := p.client.GetDefaultBranch(ctx)
			if err != nil {
				return nil, fmt.Errorf("detect default branch: %w", err)
			}
			targetBranch = defaultBranch
		}
	}

	// Use config setting for close_source_branch
	closeSourceBranch := p.config.CloseSourceBranch

	// Create the PR
	pr, err := p.client.CreatePullRequest(ctx, opts.Title, opts.Body, opts.SourceBranch, targetBranch, closeSourceBranch)
	if err != nil {
		return nil, fmt.Errorf("create pull request: %w", err)
	}

	webURL := ""
	if pr.Links.HTML != nil {
		webURL = pr.Links.HTML.Href
	}

	return &provider.PullRequest{
		ID:     fmt.Sprintf("%d", pr.ID),
		Number: pr.ID,
		URL:    webURL,
		Title:  pr.Title,
		State:  pr.State,
	}, nil
}

// GetDefaultBranch returns the repository's default branch
func (p *Provider) GetDefaultBranch(ctx context.Context) (string, error) {
	if p.config.TargetBranch != "" {
		return p.config.TargetBranch, nil
	}

	workspace := p.config.Workspace
	repoSlug := p.config.RepoSlug

	if workspace == "" || repoSlug == "" {
		return "main", nil
	}

	p.client.SetWorkspaceRepo(workspace, repoSlug)
	return p.client.GetDefaultBranch(ctx)
}

// GeneratePRTitle generates a pull request title from task metadata
func GeneratePRTitle(taskWork *storage.TaskWork) string {
	if taskWork == nil {
		return "Implementation"
	}

	var title string
	if taskWork.Metadata.ExternalKey != "" {
		title = fmt.Sprintf("[#%s] ", taskWork.Metadata.ExternalKey)
	}

	if taskWork.Metadata.Title != "" {
		title += taskWork.Metadata.Title
	} else {
		title += "Implementation"
	}

	return title
}

// GeneratePRBody generates a pull request body with implementation summary
func GeneratePRBody(taskWork *storage.TaskWork, specs []*storage.Specification, diffStat string) string {
	var sb strings.Builder

	// Summary section
	sb.WriteString("## Summary\n\n")

	if taskWork != nil && taskWork.Metadata.Title != "" {
		sb.WriteString(fmt.Sprintf("Implementation for: %s\n\n", taskWork.Metadata.Title))
	}

	// Link to issue if this is a Bitbucket issue task
	if taskWork != nil && taskWork.Source.Type == ProviderName {
		sb.WriteString(fmt.Sprintf("Closes #%s\n\n", taskWork.Metadata.ExternalKey))
	}

	// Specifications section
	if len(specs) > 0 {
		sb.WriteString("## Implementation Details\n\n")
		for _, spec := range specs {
			if spec.Title != "" {
				sb.WriteString(fmt.Sprintf("### %s\n\n", spec.Title))
			}
			// Include first 500 chars of spec content as summary
			content := spec.Content
			if len(content) > 500 {
				content = content[:500] + "..."
			}
			sb.WriteString(content)
			sb.WriteString("\n\n")
		}
	}

	// Changes section
	if diffStat != "" {
		sb.WriteString("## Changes\n\n")
		sb.WriteString("```\n")
		sb.WriteString(diffStat)
		sb.WriteString("\n```\n\n")
	}

	// Test plan section
	sb.WriteString("## Test Plan\n\n")
	sb.WriteString("- [ ] Manual testing\n")
	sb.WriteString("- [ ] Unit tests pass\n")
	sb.WriteString("- [ ] Code review\n\n")

	// Footer
	sb.WriteString("---\n")
	sb.WriteString("*Generated by [Mehrhof](https://github.com/valksor/go-mehrhof)*\n")

	return sb.String()
}

// CreatePRFromTask creates a pull request from task context
func (p *Provider) CreatePRFromTask(ctx context.Context, taskWork *storage.TaskWork, specs []*storage.Specification, sourceBranch, diffStat string) (*provider.PullRequest, error) {
	title := GeneratePRTitle(taskWork)
	body := GeneratePRBody(taskWork, specs, diffStat)

	opts := provider.PullRequestOptions{
		Title:        title,
		Body:         body,
		SourceBranch: sourceBranch,
		TargetBranch: "", // Will use default
	}

	return p.CreatePullRequest(ctx, opts)
}
